#include <Arduino.h>
#include <ArduinoJson.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <WiFi.h>
#include <esp_log.h>
#include <MQTTPubSubClient.h>
#include "Buffer.h"
#include <Wire.h>
#include <MPU6050.h>
#include <math.h>
#include <TinyGPS++.h>
#include <DHT.h>
#include <esp_log.h>

#define ledGreen 15
#define ledRed 5
#define ledBlue 18

MPU6050 mpu;
Buffer buffer; // Tamaño por defecto (15) de la cola
#define BUZZER_PIN 23
#define GPS_BAUDRATE 9600
TinyGPSPlus gps;

#define DHTPIN 4      // Pin al que está conectado el DHT11
#define DHTTYPE DHT11 // Tipo de sensor DHT (DHT11 en este caso)
DHT dht(DHTPIN, DHTTYPE);

const char *ssid = "Redmi Note 8 Pro";
const char *password = "mariomario";
const int TASK_WIFI_SIZE = 8; // Se ha decidido usar unos 8KB porque con 1KB, la pila rebosa.

WiFiClient client;
MQTTPubSubClient mqtt;

const char *broker = "waspbrain.es";
const char *mqtt_username = "sda_g1";
const char *mqtt_password = "curso2425";
const char *client_id = "mgjc";

std::mutex thresholdAcceleration_mutex;

float thresholdAcceleration = 9.5; // Umbral de aceleración m/s^2

int color = 0;

void process_state(int &color)
{
  // Apaga todos los LEDs al inicio para evitar estados residuales
  digitalWrite(ledGreen, LOW);
  digitalWrite(ledRed, LOW);
  digitalWrite(ledBlue, LOW);

  // Enciende el LED correspondiente según el color recibido
  if (color == 0)
  {
    digitalWrite(ledBlue, HIGH);
  }
  else if (color == 1)
  {
    digitalWrite(ledRed, HIGH);
  }
  else if (color == 2)
  {
    digitalWrite(ledGreen, HIGH);
  }
  else
  {
  }
}

void TaskConnectWiFi(void *pvParameters)
{
  WiFi.begin(ssid, password);
  do
  {
    // Si el estado del wifi es aún, no conectado se está reiniciando hasta que lo esté
    if (WiFi.status() != WL_CONNECTED)
    {
      WiFi.begin(ssid, password); // Inicia la conexión
      auto ini = millis();        // Variable que sirve para almacenar un tiempo 'ini'
      auto current = ini;
      color = 1;
      process_state(color);
      ESP_LOGD("TaskConnectWiFi", "Reconectando");
      // Serial.println("Reconectando");
      // Mientras que no se conecte, y la espera sea menor de 5s estaremos printeando '.' como espera.
      while (WiFi.status() != WL_CONNECTED && (current - ini) <= 5000)
      {
        Serial.print(".");
        vTaskDelay(200);
        current = millis();
      }
      ESP_LOGD("TaskConnectWiFi", "");
    }

    if (WiFi.status() == WL_CONNECTED)
    {
      
      process_state(color);
      ESP_LOGD("TaskConnectWiFi", "WiFi connected");
      Buffer ::Message msg;
      msg.topic = "sda/g1/connected/wifi";
      msg.payload = "true"; // Enviar 'true' como texto plano
      // buffer.setMessageToSend(msg);

      if (!mqtt.isConnected())
      {
        color = 0;
        client.connect(broker, 1886);
        mqtt.begin(client);
        mqtt.setKeepAliveTimeout(60); // ESTABA EN 10
        mqtt.setWill("sda/g1/state", "disconnected", true);
        mqtt.connect(client_id, mqtt_username, mqtt_password);

        auto ini = millis(); // Variable que sirve para almacenar un tiempo 'ini'
        auto current = ini;
        while (!mqtt.isConnected() && (current - ini) < 10000) // ESTABA EN 5000
        {
          vTaskDelay(200);
          current = millis();
        }
      }

      if (mqtt.isConnected())
      {
        color = 2;
        process_state(color);
        ESP_LOGD("TaskConnectWiFi", "Mqtt connected");
        msg.topic = "sda/g1/connected/MQTT";
        msg.payload = "true"; 
        //buffer.setMessageToSend(msg);
        mqtt.subscribe("sda/g1/recivido", [&](const String &payload, const size_t size)
                       {
            ESP_LOGD("TaskConnectWiFiReception", "Message received on %s", "sda/g1/recivido");
            Buffer::Message msg;
            msg.topic = "sda/g1/recivido";
            msg.payload = payload.c_str();
            buffer.setReceivedMessage(msg); });

        mqtt.subscribe("sda/g1/encender_led", [&](const String &payload, const size_t size)
                       {
            ESP_LOGD("TaskConnectWiFiReception", "Message received on %s", "sda/g1/encender_led");
            Buffer::Message msg;
            msg.topic = "sda/g1/encender_led";
            msg.payload = payload.c_str();
            buffer.setReceivedMessage(msg); });

        mqtt.subscribe("sda/g1/thresh", [&](const String &payload, const size_t size)
                       {
            ESP_LOGD("TaskConnectWiFiReception", "Message received on %s", "sda/g1/thresh");
            Buffer::Message msg;
            msg.topic = "sda/g1/thresh";
            msg.payload = payload.c_str();
            buffer.setReceivedMessage(msg); });
      }
    }
    if (WiFi.status() == WL_CONNECTED && mqtt.isConnected())
    {
      mqtt.update();
      if (buffer.isSendEmpty() == false)
      {
        Buffer ::Message msg = buffer.getMessageToSend();
        ESP_LOGD("TaskConnectWiFi", "Message to send: %s", msg.topic.c_str());
        mqtt.publish(msg.topic.c_str(), msg.payload.c_str());
      }
    }
    vTaskDelay(500);
  } while (true);
  vTaskDelete(NULL);
}

void ProcessReceivedMessages(void *pvParameters)
{
  while (true)
  {
    if (!buffer.isReceptionEmpty())
    {
      Buffer::Message rec_msg = buffer.getReceivedMessage();
      if (rec_msg.topic == "sda/g1/encender_led")
      {

        bool estado = rec_msg.payload == "true";
        digitalWrite(2, estado ? HIGH : LOW);
        ESP_LOGD("ProcRecMsgs", "LED set to %s", estado ? "ON" : "OFF");
      }
      
      JsonDocument object;
      auto error = deserializeJson(object, rec_msg.payload.c_str());
      if (!error)
      {
        if (rec_msg.topic == "sda/g1/thresh")
        {
          if (object.containsKey("thresh"))
          {
            {
              std::lock_guard<std::mutex> lock(thresholdAcceleration_mutex);
              thresholdAcceleration = object["thresh"].as<float>();
            }
            ESP_LOGD("ProcRecMsgs", "Received thresh %f", thresholdAcceleration);
          }
        }
      }
    }
    vTaskDelay(5000);
  }
}

void SensorMPU6050(void *pvParameters)
{
  Wire.begin();
  mpu.initialize();
  if (!mpu.testConnection())
  {
    ESP_LOGE("MPU6050", "Error al conectar con el MPU6050");
  }

  pinMode(BUZZER_PIN, OUTPUT); // Configurar el pin del buzzer como salida
  int alarmCounter = 0;        // Contador de activaciones de la alarma

  while (true)
  {
    Buffer ::Message msg;
    int16_t ax, ay, az;
    mpu.getAcceleration(&ax, &ay, &az);
    float ax_g = ax / 16384.0 * 9.81;
    float ay_g = ay / 16384.0 * 9.81;
    float az_g = az / 16384.0 * 9.81;
    float totalAcceleration = sqrt(pow(ax_g, 2) + pow(ay_g, 2) + pow(az_g, 2));

    ESP_LOGD("MPU6050", "Total acceleration %f", totalAcceleration);

    float threshAcc;

    {
      std::lock_guard<std::mutex> lock(thresholdAcceleration_mutex);
      threshAcc = thresholdAcceleration;
    }

    if (totalAcceleration > threshAcc)
    {
      alarmCounter++; // Incrementar el contador de alarmas
      ESP_LOGD("MPU6050", "Alarm triggered %d times", alarmCounter);

      // Crear y enviar el mensaje
      JsonDocument doc;
      doc["raw"]["ax_g"] = ax_g;
      doc["raw"]["ay_g"] = ay_g;
      doc["raw"]["az_g"] = az_g;
      doc["acc"] = totalAcceleration;

      String msg_payload;
      serializeJson(doc, msg_payload);

      msg.topic = "sda/g1/alert/accelerometer";
      msg.payload = msg_payload.c_str();
      buffer.setMessageToSend(msg);
    }

    if (alarmCounter >= 3)
    {
      msg.topic = "sda/g1/alert/alarm";
      msg.payload = "true"; // Enviar 'true' como texto plano
      buffer.setMessageToSend(msg);

      // Activar el buzzer con una secuencia de tonos
      for (int i = 0; i < 5; i++)
      {
        tone(BUZZER_PIN, 1000); // Tono alto (1000 Hz)
        vTaskDelay(pdMS_TO_TICKS(200));
        tone(BUZZER_PIN, 500); // Tono bajo (500 Hz)
        vTaskDelay(pdMS_TO_TICKS(200));
      }
      noTone(BUZZER_PIN); // Apagar el buzzer
      alarmCounter = 0;   // Reiniciar el contador de alarmas

      msg.topic = "sda/g1/alert/alarm";
      msg.payload = "false"; // Enviar 'true' como texto plano
      buffer.setMessageToSend(msg);
    }

    vTaskDelay(500);
  }
}



void SensorNEO6M(void *pvParameters)
{
  Serial2.begin(GPS_BAUDRATE); // Inicializa Serial2 con la tasa de baudios del GPS
  while (true)
  {
    if (Serial2.available() > 0)
    {

      char c = Serial2.read();
      if (gps.encode(c)) // Leer cada carácter del GPS
      {
        ESP_LOGW("NEO6M", "Leyendo caracteres");
        if (gps.location.isValid())
        {
          ESP_LOGD("NEO6M", "Lat, Lng: %f, %f", gps.location.lat(), gps.location.lng());

          JsonDocument doc;
          doc["latitud"] = gps.location.lat();
          doc["longitud"] = gps.location.lng();

          // Serialización de JSON
          String msg_payload;
          serializeJson(doc, msg_payload);

          // Configuración y envío
          Buffer::Message msg;
          msg.topic = "sda/g1/alert/gps";
          msg.payload = msg_payload.c_str();
          buffer.setMessageToSend(msg);
        }
        else
        {
          ESP_LOGW("NEO6M", "Invalid GPS data");
        }
      }
    }
    vTaskDelay(200);
  }
}

void SensorDHT11(void *pvParameters)
{
  dht.begin();
  while (true)
  {
    float humidity = dht.readHumidity();
    float temperature = dht.readTemperature();
    if (isnan(humidity) || isnan(temperature))
    {
      ESP_LOGE("DHT11", "Error reading sensor");
    }
    else
    {
      JsonDocument doc;
      doc["temperature"] = temperature;
      doc["humidity"] = humidity;

      String msg_payload;
      serializeJson(doc, msg_payload);
      Buffer::Message msg;
      msg.topic = "sda/g1/alert/temperature";
      msg.payload = msg_payload.c_str();
      buffer.setMessageToSend(msg);
      ESP_LOGD("DHT11", "Sensor values have been sent via MQTT");
    }
    vTaskDelay(10000);
  }
}

void setup()
{

  pinMode(2, OUTPUT);
  pinMode(ledGreen, OUTPUT);
  pinMode(ledRed, OUTPUT);
  pinMode(ledBlue, OUTPUT);
  esp_log_level_set("*", ESP_LOG_NONE);
  esp_log_level_set("ProcRecMsgs", ESP_LOG_DEBUG);
  esp_log_level_set("TaskConnectWiFi", ESP_LOG_DEBUG);
  esp_log_level_set("TaskConnectWiFiReception", ESP_LOG_DEBUG);
  esp_log_level_set("MPU6050", ESP_LOG_DEBUG);
  esp_log_level_set("NEO6M", ESP_LOG_DEBUG);
  esp_log_level_set("DHT11", ESP_LOG_DEBUG);

  Serial.begin(115200);
  delay(10);
  xTaskCreatePinnedToCore(TaskConnectWiFi, "Connect WiFi", TASK_WIFI_SIZE * 1024, NULL, 1, NULL, 0);
  xTaskCreatePinnedToCore(ProcessReceivedMessages, "ProcRecMsgs", TASK_WIFI_SIZE * 1024, NULL, 1, NULL, 0);
  xTaskCreatePinnedToCore(SensorMPU6050, "SensorMPU6050", 4 * 1024, NULL, 1, NULL, 1);
  xTaskCreatePinnedToCore(SensorNEO6M, "SensorNEO6M", 4 * 1024, NULL, 1, NULL, 1); 
  xTaskCreatePinnedToCore(SensorDHT11, "DHT11", 4 * 1024, NULL, 1, NULL, 1);
}

void loop()
{
  delay(1000);
}




\end{lstlisting}
\newpage

\begin{lstlisting}
    #include <WiFi.h>
#include <WiFiClient.h>
#include <PubSubClient.h>
#include <Wire.h>

// Configuración de WiFi
#define WIFI_SSID "Redmi Note 8 Pro"
#define WIFI_PASSWORD "mariomario"
#define WIFI_CHANNEL 6

#define SLAVE_ADDRESS 0x08

// Configuración de MQTT
const char *MQTT_BROKER_ADRESS = "broker.mqtt.cool";
const uint16_t MQTT_PORT = 1883;
const char *MQTT_CLIENT_NAME = "car_control";
int32_t dist = 0;
// Pines del controlador de motores
#define MOTOR1_1 27
#define MOTOR1_2 14
#define MOTOR2_1 12
#define MOTOR2_2 13

#define led_green 15
#define led_red 2
#define led_blue 4
#define LED_distance 23

// Pines del sensor ultrasónico
#define TRIG_PIN 18
#define ECHO_PIN 19


// Variables globales
WiFiClient espClient;
PubSubClient mqttClient(espClient);
String content = ""; // Contenido del mensaje recibido

// Configuración de PWM para el ESP32
const int freq = 5000;    // Frecuencia PWM
const int resolution = 8; // Resolución de 8 bits (0-255)
const int channel1 = 0;   // Canal PWM para MOTOR1_1
const int channel2 = 1;   // Canal PWM para MOTOR1_2
const int channel3 = 2;   // Canal PWM para MOTOR2_1
const int channel4 = 3;   // Canal PWM para MOTOR2_2
volatile bool activated = false;

int speed = 80; // Velocidad inicial (máxima)

// Configuración de los pines PWM
void setupPWM()
{
  ledcSetup(channel1, freq, resolution);
  ledcSetup(channel2, freq, resolution);
  ledcSetup(channel3, freq, resolution);
  ledcSetup(channel4, freq, resolution);

  ledcAttachPin(MOTOR1_1, channel1);
  ledcAttachPin(MOTOR1_2, channel2);
  ledcAttachPin(MOTOR2_1, channel3);
  ledcAttachPin(MOTOR2_2, channel4);
}

// Funciones de control de motores
void moverMotor(int m1_pin1, int m1_pin2, int m2_pin1, int m2_pin2)
{
  ledcWrite(channel1, m1_pin1 ? speed : 0);
  ledcWrite(channel2, m1_pin2 ? speed : 0);
  ledcWrite(channel3, m2_pin1 ? speed : 0);
  ledcWrite(channel4, m2_pin2 ? speed : 0);
}

void driveForward()
{
  moverMotor(1, 0, 1, 0); // Adelante
}

void driveBackward()
{
  moverMotor(0, 1, 0, 1); // Atrás
}

void turnLeft()
{
  moverMotor(1, 0, 0, 1); // Girar a la izquierda
}

void turnRight()
{
  moverMotor(0, 1, 1, 0); // Girar a la derecha
}

void stopMotors()
{
  moverMotor(0, 0, 0, 0); // Detener todos los motores
}

// dist, se gestiona así porque se pasan en 1 byte.

void control()
{
  if (activated)
  {
    if (dist > 100)
    {
      turnRight();
    }
    else if (dist < 60)
    {
      turnLeft();
    }
    else
    {
      driveForward();
    }
  }
}

void receiveEvent(int bytes)
{
  while (Wire.available())
  {
    dist = Wire.read(); // Leer un byte de los datos recibidos
  }

  Serial.print("Distancia recibida: ");
  Serial.println(dist);
  control();
}

void OnMqttReceived(char *topic, byte *payload, unsigned int length)
{
  Serial.print("Mensaje recibido en ");
  Serial.print(topic);
  Serial.print(": ");

  content = "";
  for (unsigned int i = 0; i < length; i++)
  {
    content += (char)payload[i];
  }
  Serial.println(content);

  if (String(topic) == "car/move")
  {
    if (content == "forward")
      driveForward();
    else if (content == "backward")
      driveBackward();
    else if (content == "left")
      turnLeft();
    else if (content == "right")
      turnRight();
    else if (content == "stop")
      stopMotors();
  }

  if (String(topic) == "car/speed")
  {
    int newSpeed = content.toInt();
    speed = constrain(newSpeed, 0, 255); // Limitar el rango de velocidad
    Serial.print("Velocidad ajustada a: ");
    Serial.println(speed);
  }

  if (String(topic) == "car/automatic")
  {
    if (content == "activated")
    {
      activated = true;
      Wire.begin(SLAVE_ADDRESS);    // Iniciar I2C como esclavo
      Wire.onReceive(receiveEvent); // Función para manejar los datos recibidos
    }
    if (content == "desactivated")
    {
      Wire.end();
    }
  }
}

// Conexión a WiFi
void ConnectWiFi()
{
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD, WIFI_CHANNEL);
  Serial.print("Conectando a WiFi: ");
  Serial.print(WIFI_SSID);
  while (WiFi.status() != WL_CONNECTED)
  {
    digitalWrite(led_blue, HIGH);
    digitalWrite(led_green, LOW);
    digitalWrite(led_red, LOW);
    delay(100);
    Serial.print(".");
  }
  Serial.println("\nConectado a WiFi!");
  Serial.print("Dirección IP: ");
  Serial.println(WiFi.localIP());
}

// Configuración inicial de MQTT
void InitMqtt()
{
  mqttClient.setServer(MQTT_BROKER_ADRESS, MQTT_PORT);
  mqttClient.setCallback(OnMqttReceived);
}

// Conexión al servidor MQTT
void ConnectMqtt()
{
  while (!mqttClient.connected())
  {
    Serial.println("Intentando conectar al servidor MQTT...");
    if (mqttClient.connect(MQTT_CLIENT_NAME))
    {
      digitalWrite(led_green, HIGH);
      digitalWrite(led_blue, LOW);
      digitalWrite(led_red, LOW);
      
      Serial.println("¡Conexión exitosa al servidor MQTT!");
      mqttClient.subscribe("car/move");      // Comandos de movimiento
      mqttClient.subscribe("car/speed");     // Comando de velocidad
      mqttClient.subscribe("car/automatic"); // Comando de si es modo automatico o manual
    }
    else
    {
      Serial.print("Falló la conexión, estado=");
      Serial.println(mqttClient.state());
      delay(5000);
    }
  }
  pinMode(led_red,HIGH);
  pinMode(led_blue,LOW);
  pinMode(led_green,LOW);
}

long medirDistancia()
{
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH);
  long distance = duration * 0.034 / 2; // Convertir a cm
  return distance;
}

// Control basado en distancia
void controlarDistancia()
{
  if (activated) // Solo en automatico
  {
    long distancia = medirDistancia();
    if (distancia < 20)
    {
      //Serial.println("shit");
      digitalWrite(LED_distance, HIGH); // Enciende el LED rojo
      stopMotors();
    }
    else
    {
      digitalWrite(LED_distance, LOW); // Apaga el LED rojo
    }
  }
}

// Configuración inicial
void setup()
{
  Serial.begin(115200);

  // Configuración de pines de motores como salida
  pinMode(MOTOR1_1, OUTPUT);
  pinMode(MOTOR1_2, OUTPUT);
  pinMode(MOTOR2_1, OUTPUT);
  pinMode(MOTOR2_2, OUTPUT);

  pinMode(led_green, OUTPUT);
  pinMode(led_red, OUTPUT);
  pinMode(led_blue, OUTPUT);
  pinMode(LED_distance,OUTPUT);

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  setupPWM();
  ConnectWiFi();
  InitMqtt();
}

// Bucle principal
void loop()
{
  if (!mqttClient.connected())
  {
    Serial.println("MQTT desconectado. Intentando reconectar...");
    ConnectMqtt();
  }
  mqttClient.loop();
  controlarDistancia(); 
}
\end{lstlisting}

\begin{lstlisting}
    #include <WiFi.h>
#include <WiFiClientSecure.h>
#include "esp_camera.h"
#include "soc/soc.h"
#include "soc/rtc_cntl_reg.h"
#include "index_OCV_ColorTrack.h"
#include "PubSubClient.h"
#include <Wire.h>


#define SLAVE_ADDR 8  // Dirección del esclavo (ESP32 normal)


// Replace with your network credentials
/*const char* ssid = "Redmi Note 8 Pro";
const char* password = "mariomario";*/

const char* ssid = "pablopablo";
const char* password = "pablo777";


String Feedback = "";
String Command = "", cmd = "", P1 = "", P2 = "", P3 = "", P4 = "", P5 = "", P6 = "", P7 = "", P8 = "", P9 = "";
byte ReceiveState = 0, cmdState = 1, strState = 1, questionstate = 0, equalstate = 0, semicolonstate = 0;
//ANN:0
//       AI-Thinker
#define PWDN_GPIO_NUM 32
#define RESET_GPIO_NUM -1
#define XCLK_GPIO_NUM 0
#define SIOD_GPIO_NUM 26
#define SIOC_GPIO_NUM 27
#define Y9_GPIO_NUM 35
#define Y8_GPIO_NUM 34
#define Y7_GPIO_NUM 39
#define Y6_GPIO_NUM 36
#define Y5_GPIO_NUM 21
#define Y4_GPIO_NUM 19
#define Y3_GPIO_NUM 18
#define Y2_GPIO_NUM 5
#define VSYNC_GPIO_NUM 25
#define HREF_GPIO_NUM 23
#define PCLK_GPIO_NUM 22

WiFiServer server(80);
//ANN:2


void ExecuteCommand() {
  if (cmd != "colorDetect") {  //Omit printout
    //Serial.println("cmd= "+cmd+" ,P1= "+P1+" ,P2= "+P2+" ,P3= "+P3+" ,P4= "+P4+" ,P5= "+P5+" ,P6= "+P6+" ,P7= "+P7+" ,P8= "+P8+" ,P9= "+P9);
    //Serial.println("");
  }

  if (cmd == "resetwifi") {
    WiFi.begin(P1.c_str(), P2.c_str());
    Serial.print("Connecting to ");
    Serial.println(P1);
    long int StartTime = millis();
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      if ((StartTime + 5000) < millis()) break;
    }
    Serial.println("");
    Serial.println("STAIP: " + WiFi.localIP().toString());
    Feedback = "STAIP: " + WiFi.localIP().toString();
  } else if (cmd == "restart") {
    ESP.restart();
  } else if (cmd == "cm") {
    int16_t XcmVal = P1.toInt();
    int16_t YcmVal = P2.toInt();
    Serial.println("cmd= " + cmd + " ,VALXCM= " + XcmVal);
    Serial.println("cmd= " + cmd + " ,VALYCM= " + YcmVal);
    int Xreal = XcmVal/2;
    Wire.beginTransmission(SLAVE_ADDR);  // Iniciar transmisión al esclavo             
    Wire.write(Xreal);                  // Enviar el dato al esclavo
    Wire.endTransmission();              // Finalizar transmisión
  } else if (cmd == "quality") {
    sensor_t* s = esp_camera_sensor_get();
    int val = P1.toInt();
    s->set_quality(s, val);
  } else if (cmd == "contrast") {
    sensor_t* s = esp_camera_sensor_get();
    int val = P1.toInt();
    s->set_contrast(s, val);
  } else if (cmd == "brightness") {
    sensor_t* s = esp_camera_sensor_get();
    int val = P1.toInt();
    s->set_brightness(s, val);
  } else {
    Feedback = "Command is not defined.";
  }
  if (Feedback == "") {
    Feedback = Command;
  }
}

void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);

  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println();
  Wire.begin(14, 15);  // Inicializar el I2C como maestro

  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  //init with high specs to pre-allocate larger buffers
  if (psramFound()) {
    config.frame_size = FRAMESIZE_UXGA;
    config.jpeg_quality = 10;  //0-63 lower number means higher quality
    config.fb_count = 2;
  } else {
    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 12;  //0-63 lower number means higher quality
    config.fb_count = 1;
  }

  // camera init
  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x", err);
    delay(1000);
    ESP.restart();
  }

  //drop down frame size for higher initial frame rate
  sensor_t* s = esp_camera_sensor_get();
  s->set_framesize(s, FRAMESIZE_CIF);  //UXGA|SXGA|XGA|SVGA|VGA|CIF|QVGA|HQVGA|QQVGA  設定初始化影像解析度

  WiFi.mode(WIFI_AP_STA);
  WiFi.begin(ssid, password);

  delay(1000);

  long int StartTime = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    if ((StartTime + 10000) < millis())
      break;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("ESP IP Address: http://");
    Serial.println(WiFi.localIP());
  }
  server.begin();
}



void loop() {
  Feedback = "";
  Command = "";
  cmd = "";
  P1 = "";
  P2 = "";
  P3 = "";
  P4 = "";
  P5 = "";
  P6 = "";
  P7 = "";
  P8 = "";
  P9 = "";
  ReceiveState = 0;
  cmdState = 1;
  strState = 1;
  questionstate = 0;
  equalstate = 0;
  semicolonstate = 0;
  WiFiClient client = server.available();


  if (client) {
    String currentLine = "";

    while (client.connected()) {
      if (client.available()) {
        char c = client.read();

        getCommand(c);

        if (c == '\n') {
          if (currentLine.length() == 0) {

            if (cmd == "colorDetect") {
              camera_fb_t* fb = NULL;
              fb = esp_camera_fb_get();
              if (!fb) {
                Serial.println("Camera capture failed");
                delay(1000);
                ESP.restart();
              }
              //ANN:1
              client.println("HTTP/1.1 200 OK");
              client.println("Access-Control-Allow-Origin: *");
              client.println("Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept");
              client.println("Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS");
              client.println("Content-Type: image/jpeg");
              client.println("Content-Disposition: form-data; name=\"imageFile\"; filename=\"picture.jpg\"");
              client.println("Content-Length: " + String(fb->len));
              client.println("Connection: close");
              client.println();

              uint8_t* fbBuf = fb->buf;
              size_t fbLen = fb->len;
              for (size_t n = 0; n < fbLen; n = n + 1024) {
                if (n + 1024 < fbLen) {
                  client.write(fbBuf, 1024);
                  fbBuf += 1024;
                } else if (fbLen % 1024 > 0) {
                  size_t remainder = fbLen % 1024;
                  client.write(fbBuf, remainder);
                }
              }
              esp_camera_fb_return(fb);
            } else {
              //ANN:1
              client.println("HTTP/1.1 200 OK");
              client.println("Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept");
              client.println("Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS");
              client.println("Content-Type: text/html; charset=utf-8");
              client.println("Access-Control-Allow-Origin: *");
              client.println("Connection: close");
              client.println();
              String Data = "";
              if (cmd != "")
                Data = Feedback;
              else {
                Data = String((const char*)INDEX_HTML);
              }
              int Index;
              for (Index = 0; Index < Data.length(); Index = Index + 1000) {
                client.print(Data.substring(Index, Index + 1000));
              }
              client.println();
            }

            Feedback = "";
            break;
          } else {
            currentLine = "";
          }
        } else if (c != '\r') {
          currentLine += c;
        }
        if ((currentLine.indexOf("/?") != -1) && (currentLine.indexOf(" HTTP") != -1)) {
          if (Command.indexOf("stop") != -1) {
            client.println();
            client.println();
            client.stop();
          }
          currentLine = "";
          Feedback = "";
          ExecuteCommand();
        }
      }
    }
    //delay(1);
    client.stop();
  }
}

void getCommand(char c) {
  if (c == '?') ReceiveState = 1;
  if ((c == ' ') || (c == '\r') || (c == '\n')) ReceiveState = 0;

  if (ReceiveState == 1) {
    Command = Command + String(c);
    if (c == '=') cmdState = 0;
    if (c == ';') strState++;
    if ((cmdState == 1) && ((c != '?') || (questionstate == 1))) cmd = cmd + String(c);
    if ((cmdState == 0) && (strState == 1) && ((c != '=') || (equalstate == 1))) P1 = P1 + String(c);
    if ((cmdState == 0) && (strState == 2) && (c != ';')) P2 = P2 + String(c);
    if ((cmdState == 0) && (strState == 3) && (c != ';')) P3 = P3 + String(c);
    if ((cmdState == 0) && (strState == 4) && (c != ';')) P4 = P4 + String(c);
    if ((cmdState == 0) && (strState == 5) && (c != ';')) P5 = P5 + String(c);
    if ((cmdState == 0) && (strState == 6) && (c != ';')) P6 = P6 + String(c);
    if ((cmdState == 0) && (strState == 7) && (c != ';')) P7 = P7 + String(c);
    if ((cmdState == 0) && (strState == 8) && (c != ';')) P8 = P8 + String(c);
    if ((cmdState == 0) && (strState >= 9) && ((c != ';') || (semicolonstate == 1))) P9 = P9 + String(c);
    if (c == '?') questionstate = 1;
    if (c == '=') equalstate = 1;
    if ((strState >= 9) && (c == ';')) semicolonstate = 1;
  }
}


